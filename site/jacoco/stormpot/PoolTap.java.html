<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PoolTap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stormpot</a> &gt; <a href="index.source.html" class="el_package">stormpot</a> &gt; <span class="el_source">PoolTap.java</span></div><h1>PoolTap.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2011-2019 Chris Vest (mr.chrisvest@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package stormpot;

import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * A PoolTap provides the API for accessing objects in a {@link Pool}.
 *
 * PoolTaps are not necessarily thread-safe, but pools, which extend PoolTap,
 * are always thread-safe.
 *
 * @author Chris Vest &lt;mr.chrisvest@gmail.com&gt;
 * @param &lt;T&gt; the type of {@link Poolable} contained in the pool, and made
 *          available via this pool tap, as determined by the
 *          {@linkplain Pool#from(Allocator) configured allocator}.
 * @see stormpot.Pool
 */
public abstract class PoolTap&lt;T extends Poolable&gt; {
<span class="fc" id="L36">  PoolTap() {</span>
<span class="fc" id="L37">  }</span>

  /**
   * Claim the exclusive rights until released, to an object in the pool.
   * Possibly waiting up to the specified amount of time, as given by the
   * provided {@link Timeout} instance, for one to become available if the
   * pool has been depleted. If the timeout elapses before an object can be
   * claimed, then `null` is returned instead. The timeout will be
   * honoured even if the Allocators {@link Allocator#allocate(Slot) allocate}
   * methods blocks forever. If the given timeout has a zero or negative value,
   * then the method will not wait.
   *
   * If the current thread has already one or more objects currently claimed,
   * then a distinct object will be returned, if one is or becomes available.
   * This means that it is possible for a single thread to deplete the pool, if
   * it so desires. However, doing so is inherently deadlock prone, so avoid
   * claiming more than one object at a time per thread, if at all possible.
   *
   * This method may throw a PoolException if the pool have trouble allocating
   * objects. That is, if its assigned Allocator throws exceptions from its
   * allocate method, or returns `null`.
   *
   * An {@link InterruptedException} will be thrown if the thread has its
   * interrupted flag set upon entry to this method, or is interrupted while
   * waiting. The interrupted flag on the thread will be cleared after
   * this, as per the general contract of interruptible methods.
   *
   * If the pool has been shut down, then an {@link IllegalStateException} will
   * be thrown when this method is called. Likewise if we are waiting for an
   * object to become available, and someone shuts the pool down.
   *
   * Here's an example code snippet, where an object is claimed, printed to
   * `System.out`, and then released back to the pool:
   *
   * [source,java]
   * ----
   * include::../src/test/java/examples/Examples.java[tag=poolClaimPrintExample]
   * ----
   *
   * Memory effects:
   *
   * * The {@link Poolable#release() release} of an object happens-before
   *   any subsequent claim or {@link Allocator#deallocate(Poolable)
   *   deallocation} of that object, and,
   * * The {@link Allocator#allocate(Slot) allocation} of an object
   *   happens-before any claim of that object.
   *
   * @param timeout The timeout of the maximum permitted time-slice to wait for
   * an object to become available. A timeout with a value of zero or less
   * means that the call will do no waiting, preferring instead to return early
   * if no objects are available.
   * @return An object of the Poolable subtype T to which the exclusive rights
   * have been claimed, or `null` if the timeout period elapsed
   * before an object became available.
   * @throws PoolException If an object allocation failed because the Allocator
   * threw an exception from its allocate method, or returned
   * `null`, or the
   * {@link Expiration#hasExpired(SlotInfo) expiration check} threw an
   * exception.
   * @throws InterruptedException if the current thread is
   * {@link Thread#interrupt() interrupted} upon entry, or becomes interrupted
   * while waiting.
   * @throws IllegalArgumentException if the `timeout` argument is `null`.
   */
  public abstract T claim(Timeout timeout)
      throws PoolException, InterruptedException;

  /**
   * Claim an object from the pool and apply the given function to it, returning
   * the result and releasing the object back to the pool.
   *
   * If an object cannot be claimed within the given timeout, then
   * {@link Optional#empty()} is returned instead. The `empty()` value is also
   * returned if the function returns `null`.
   *
   * @param timeout The timeout of the maximum permitted amount of time to wait
   * for an object to become available. A timeout with a value of zero or less
   * means that the call will do no waiting, preferring instead to return early
   * if no objects are available.
   * @param function The function to apply to the claimed object, if any. The
   * function should avoid further claims, since having more than one object
   * claimed at a time per thread is inherently deadlock prone.
   * @param &lt;R&gt; The return type of the given function.
   * @return an {@link Optional} of either the return value of applying the
   * given function to a claimed object, or empty if the timeout elapsed or
   * the function returned `null`.
   * @throws InterruptedException if the thread was interrupted.
   * @see #claim(Timeout) The `claim` method for more details on failure modes
   * and memory effects.
   */
  public final &lt;R&gt; Optional&lt;R&gt; apply(Timeout timeout, Function&lt;T, R&gt; function)
      throws InterruptedException {
<span class="fc" id="L129">    Objects.requireNonNull(function, &quot;Function cannot be null.&quot;);</span>
<span class="fc" id="L130">    T obj = claim(timeout);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L132">      return Optional.empty();</span>
    }
    try {
<span class="fc" id="L135">      return Optional.ofNullable(function.apply(obj));</span>
    } finally {
<span class="fc" id="L137">      obj.release();</span>
    }
  }

  /**
   * Claim an object from the pool and supply it to the given consumer, and then
   * release it back to the pool.
   *
   * If an object cannot be claimed within the given timeout, then this method
   * returns `false`. Otherwise, if an object was claimed and supplied to the
   * consumer, the method returns `true`.
   * @param timeout The timeout of the maximum permitted amount of time to wait
   * for an object to become available. A timeout with a value of zero or less
   * means that the call will do no waiting, preferring instead to return early
   * if no objects are available.
   * @param consumer The consumer to pass the claimed object to, if any. The
   * consumer should avoid further claims, since having more than one object
   * claimed at a time per thread is inherently deadlock prone.
   * @return `true` if an object could be claimed within the given timeout and
   * passed to the given consumer, or `false` otherwise.
   * @throws InterruptedException if the thread was interrupted.
   * @see #claim(Timeout) The `claim` method for more details on failure modes
   * and memory effects.
   */
  public final boolean supply(Timeout timeout, Consumer&lt;T&gt; consumer)
      throws InterruptedException {
<span class="fc" id="L163">    Objects.requireNonNull(consumer, &quot;Consumer cannot be null.&quot;);</span>
<span class="fc" id="L164">    T obj = claim(timeout);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L166">      return false;</span>
    }
    try {
<span class="fc" id="L169">      consumer.accept(obj);</span>
<span class="fc" id="L170">      return true;</span>
    } finally {
<span class="fc" id="L172">      obj.release();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>